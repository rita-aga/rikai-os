# Rust Umi Library Implementation

**Status**: IN PROGRESS
**Created**: 2026-01-10
**Type**: Implementation
**Decision**: Option B (Rust library with PyO3 bindings)

---

## Decision Summary

After analyzing options A-D:
- **Option B selected**: Rust library with PyO3 bindings
- Kelpie: native Rust dependency (`cargo add umi`)
- RikaiOS: PyO3 bindings (`pip install umi-py`)
- Each app has its own Umi instance with its own DB

See ADR-004 for full decision rationale.

---

## TigerStyle Rules (Ported from Python)

### Naming Conventions (Big-Endian)

```rust
// Category first, specifics last
const ENTITY_CONTENT_BYTES_MAX: usize = 1_000_000;      // Good
const MAX_ENTITY_CONTENT_BYTES: usize = 1_000_000;      // Bad

const STORAGE_RETRY_COUNT_MAX: u32 = 3;                 // Good
const MAX_RETRIES: u32 = 3;                             // Bad

const WORKING_MEMORY_TTL_SECS_DEFAULT: u64 = 3600;      // Good
const DEFAULT_TTL: u64 = 3600;                          // Bad
```

### Assertions (2+ per function)

```rust
pub fn store_entity(&mut self, entity: Entity) -> Result<String> {
    // Preconditions
    assert!(!entity.id.is_empty(), "entity must have id");
    assert!(
        entity.content.len() <= ENTITY_CONTENT_BYTES_MAX,
        "content exceeds {} bytes", ENTITY_CONTENT_BYTES_MAX
    );

    let result = self.storage.insert(entity)?;

    // Postconditions
    assert_eq!(result.id, entity.id, "stored id must match");
    assert!(result.created_at.is_some(), "must have timestamp");

    Ok(result.id)
}
```

### Explicit Limits

```rust
// Every limit is a named constant with units in the name
pub const CORE_MEMORY_SIZE_BYTES_MAX: usize = 32 * 1024;        // 32KB
pub const CORE_MEMORY_SIZE_BYTES_MIN: usize = 4 * 1024;         // 4KB
pub const WORKING_MEMORY_SIZE_BYTES_MAX: usize = 1024 * 1024;   // 1MB
pub const WORKING_MEMORY_ENTRY_SIZE_BYTES_MAX: usize = 64 * 1024;
pub const WORKING_MEMORY_TTL_SECS_DEFAULT: u64 = 3600;          // 1 hour
pub const SEARCH_RESULTS_COUNT_MAX: usize = 100;
pub const ENTITY_CONTENT_BYTES_MAX: usize = 1_000_000;          // 1MB
pub const EMBEDDING_DIMENSIONS_COUNT: usize = 1536;
```

---

## Simulation-First Implementation Order

```
Phase 1: DST Framework (Rust)
├── SimConfig (seed management)
├── DeterministicRng (ChaCha20)
├── SimClock (controllable time)
├── FaultInjector (probabilistic faults)
└── SimStorage (in-memory with faults)

Phase 2: Core Types (test-first)
├── MemoryBlock + MemoryBlockType
├── CoreMemory (32KB, always in context)
└── WorkingMemory (1MB KV with TTL)

Phase 3: Storage Backends (test-first)
├── StorageBackend trait
├── PostgresBackend (production)
└── Tests use SimStorage

Phase 4: PyO3 Bindings
├── umi-py crate
├── Python type conversions
└── Async runtime bridge
```

---

## Workspace Structure

```
umi/
├── Cargo.toml              # Workspace root
├── umi-core/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── constants.rs    # All _MAX, _MIN, _DEFAULT constants
│       ├── dst/
│       │   ├── mod.rs
│       │   ├── config.rs   # SimConfig
│       │   ├── rng.rs      # DeterministicRng (ChaCha20)
│       │   ├── clock.rs    # SimClock
│       │   ├── fault.rs    # FaultInjector, FaultType
│       │   └── storage.rs  # SimStorage
│       ├── types/
│       │   ├── mod.rs
│       │   ├── memory_block.rs
│       │   └── entity.rs
│       ├── memory/
│       │   ├── mod.rs
│       │   ├── core.rs     # CoreMemory
│       │   └── working.rs  # WorkingMemory
│       └── storage/
│           ├── mod.rs
│           ├── backend.rs  # StorageBackend trait
│           └── postgres.rs # PostgresBackend
├── umi-py/
│   ├── Cargo.toml          # PyO3 bindings
│   └── src/
│       └── lib.rs
└── umi-cli/
    ├── Cargo.toml
    └── src/
        └── main.rs
```

---

## Phase 1: DST Framework

### Files to Create

1. `umi/Cargo.toml` - Workspace root
2. `umi/umi-core/Cargo.toml` - Core library
3. `umi/umi-core/src/lib.rs` - Library entry
4. `umi/umi-core/src/constants.rs` - TigerStyle constants
5. `umi/umi-core/src/dst/mod.rs` - DST module
6. `umi/umi-core/src/dst/config.rs` - SimConfig
7. `umi/umi-core/src/dst/rng.rs` - DeterministicRng
8. `umi/umi-core/src/dst/clock.rs` - SimClock
9. `umi/umi-core/src/dst/fault.rs` - FaultInjector
10. `umi/umi-core/src/dst/storage.rs` - SimStorage

### Dependencies

```toml
[dependencies]
rand = "0.8"
rand_chacha = "0.3"           # Deterministic RNG
tokio = { version = "1", features = ["full"] }
thiserror = "1"               # Error handling
async-trait = "0.1"

[dev-dependencies]
tokio-test = "0.4"
```

---

## Instance Log

| Time | Instance | Action |
|------|----------|--------|
| 2026-01-10 23:00 | Main | Started Rust Umi implementation plan |
| 2026-01-10 23:15 | Main | Created ADR-004 documenting Rust decision |
| 2026-01-10 23:20 | Main | Created workspace structure (umi-core, umi-py, umi-cli) |
| 2026-01-10 23:30 | Main | Implemented DST framework (config, rng, clock, fault, storage, simulation) |
| 2026-01-10 23:45 | Main | All 67 tests passing (59 unit + 8 doc tests) |
| 2026-01-11 | Main | Enhanced DST: SimClock async sleep/notify, SimNetwork with partitions |
| 2026-01-11 | Main | Implemented CoreMemory: MemoryBlockType, MemoryBlock, CoreMemory |
| 2026-01-11 | Main | Added DST tests for CoreMemory, 122 tests passing |
| 2026-01-11 | Main | Removed unused custom_blocks scaffolding from CoreMemory |
| 2026-01-11 | Main | Added edge case tests (unicode, empty strings, max labels) |
| 2026-01-11 | Main | Added property-based testing framework (PropertyTest, PropertyTestable) |
| 2026-01-11 | Main | 126 tests passing |
| 2026-01-11 | Main | Implemented WorkingMemory simulation-first (tests before implementation) |
| 2026-01-11 | Main | 148 tests passing (22 new WorkingMemory tests) |
| 2026-01-11 | Main | Started Phase 3: StorageBackend trait |
| 2026-01-11 | Main | Created ADR-005: Storage Backend Trait design |
| 2026-01-11 | Main | Implemented Entity, EntityType, StorageBackend trait |
| 2026-01-11 | Main | Implemented SimStorageBackend (simulation-first, DST tests, property tests) |
| 2026-01-11 | Main | 176 tests passing (28 new storage tests) |
| 2026-01-11 | Main | Implemented ArchivalMemory (Tier 3 high-level API, simulation-first) |
| 2026-01-11 | Main | 195 tests passing (19 new ArchivalMemory tests) |
| 2026-01-11 | Main | Implemented PostgresBackend (sqlx, connection pooling, upsert, ILIKE search) |
| 2026-01-11 | Main | Phase 3 complete - 195 tests passing, postgres feature builds |
| 2026-01-11 | Main | Phase 4: PyO3 bindings - CoreMemory, WorkingMemory, Entity exposed to Python |
| 2026-01-11 | Main | Added pyproject.toml for maturin build |

---

## Completed

- [x] Decision: Option B (Rust library + PyO3)
- [x] Created plan file
- [x] ADR-004: Rust Umi decision
- [x] Workspace Cargo.toml
- [x] umi-core/src/constants.rs - TigerStyle constants
- [x] umi-core/src/dst/config.rs - SimConfig
- [x] umi-core/src/dst/rng.rs - DeterministicRng (ChaCha20)
- [x] umi-core/src/dst/clock.rs - SimClock (with async sleep/notify)
- [x] umi-core/src/dst/fault.rs - FaultInjector (26 fault types)
- [x] umi-core/src/dst/storage.rs - SimStorage
- [x] umi-core/src/dst/network.rs - SimNetwork (partitions, latency, jitter)
- [x] umi-core/src/dst/simulation.rs - Simulation harness
- [x] umi-core/src/dst/property.rs - PropertyTest (property-based testing)
- [x] umi-core/src/memory/block.rs - MemoryBlockType, MemoryBlock
- [x] umi-core/src/memory/core.rs - CoreMemory (32KB, type-indexed)
- [x] umi-core/src/memory/working.rs - WorkingMemory (1MB KV with TTL, simulation-first)
- [x] ADR-005: Storage Backend Trait design
- [x] umi-core/src/storage/entity.rs - Entity, EntityType, EntityBuilder
- [x] umi-core/src/storage/error.rs - StorageError
- [x] umi-core/src/storage/backend.rs - StorageBackend trait
- [x] umi-core/src/storage/sim.rs - SimStorageBackend (DST + property tests)
- [x] umi-core/src/memory/archival.rs - ArchivalMemory (Tier 3 high-level API)
- [x] umi-core/src/storage/postgres.rs - PostgresBackend (sqlx, upsert, ILIKE search)
- [x] Phase 3 complete - 195 tests passing
- [x] umi-py/src/lib.rs - PyO3 bindings (CoreMemory, WorkingMemory, Entity)
- [x] umi-py/pyproject.toml - Maturin build configuration

## CoreMemory Implementation Notes

**Improvements over Kelpie:**
- Simpler API: `set_block(type, content)` instead of separate add/update
- Type-indexed: One block per type (simpler mental model)
- Deterministic render order via block type priority
- Integrated timestamps for DST compatibility

**Features:**
- 6 block types: System, Persona, Human, Facts, Goals, Scratch
- XML rendering for LLM context: `<core_memory><block type="...">...</block></core_memory>`
- Size tracking with cached byte counts
- TigerStyle assertions (2+ per function)
- DST tests with SimClock integration

## Next Steps

- [x] WorkingMemory implementation (simulation-first) ✓
- [x] Phase 3: StorageBackend trait + PostgresBackend ✓
- [x] Phase 4: PyO3 bindings for RikaiOS ✓

**All phases complete!** The Umi Rust library is ready for use.

---

## WorkingMemory Implementation Notes

**Simulation-First Approach:**
- Tests written FIRST with `todo!()` stubs
- Tests verified to fail before implementation
- Implementation added to make tests pass
- Property-based tests verify invariants under random operations

**Features:**
- Session-scoped KV store (~1MB capacity)
- TTL-based expiration (default 1 hour)
- DST integration via `set_clock_ms()` for controllable time
- 22 tests: 10 basic CRUD, 6 DST with SimClock, 3 property-based, 3 capacity limits

**API:**
```rust
impl WorkingMemory {
    pub fn new() -> Self;
    pub fn with_config(config: WorkingMemoryConfig) -> Self;
    pub fn set_clock_ms(&mut self, ms: u64);  // DST integration
    pub fn set(&mut self, key: &str, value: &[u8], ttl_ms: Option<u64>) -> Result<()>;
    pub fn get(&self, key: &str) -> Option<&[u8]>;
    pub fn delete(&mut self, key: &str) -> bool;
    pub fn exists(&self, key: &str) -> bool;
    pub fn cleanup_expired(&mut self) -> usize;
    pub fn used_bytes(&self) -> usize;
    pub fn entry_count(&self) -> usize;
    pub fn clear(&mut self);
}
```

---

## WorkingMemory Design (Simulation-First)

**What it is:** Session-scoped KV store with TTL expiration (~1MB capacity)

**Constants (from constants.rs):**
```rust
WORKING_MEMORY_SIZE_BYTES_MAX: 1MB        // Total capacity
WORKING_MEMORY_ENTRY_SIZE_BYTES_MAX: 64KB // Max single entry
WORKING_MEMORY_TTL_SECS_DEFAULT: 3600     // 1 hour default TTL
WORKING_MEMORY_TTL_SECS_MAX: 604800       // 7 days max TTL
WORKING_MEMORY_ENTRIES_COUNT_MAX: 10_000  // Max entry count
```

**Simulation-First Approach:**
1. Write failing DST tests first
2. Define behaviors via tests before implementation
3. Implement to make tests pass

**Key Behaviors to Test (DST):**
1. TTL expiration - entries expire after TTL (SimClock)
2. Capacity limits - byte limit and entry count limit
3. Entry CRUD - set/get/delete/exists
4. Overwrite updates TTL - setting existing key resets TTL
5. Cleanup - expired entries are removed
6. Size tracking - accurate byte counting
7. Property-based - random operations maintain invariants

**API Design:**
```rust
pub struct WorkingMemory {
    // Internal: HashMap<String, Entry> with TTL metadata
}

impl WorkingMemory {
    pub fn new() -> Self;
    pub fn with_config(config: WorkingMemoryConfig) -> Self;
    pub fn set_clock_ms(&mut self, ms: u64);  // DST integration

    // CRUD
    pub fn set(&mut self, key: &str, value: &[u8], ttl_ms: Option<u64>) -> Result<()>;
    pub fn get(&self, key: &str) -> Option<&[u8]>;
    pub fn delete(&mut self, key: &str) -> bool;
    pub fn exists(&self, key: &str) -> bool;

    // Maintenance
    pub fn cleanup_expired(&mut self) -> usize;  // Returns count removed

    // Stats
    pub fn used_bytes(&self) -> usize;
    pub fn entry_count(&self) -> usize;
    pub fn is_empty(&self) -> bool;
}
```

---

## Phase 3: Storage Backends (Simulation-First)

**Goal**: Connect in-memory types to persistent storage via abstract trait.

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    StorageBackend Trait                      │
├─────────────────────────────────────────────────────────────┤
│  store_entity(entity) → Result<EntityId>                     │
│  get_entity(id) → Result<Option<Entity>>                     │
│  delete_entity(id) → Result<bool>                            │
│  search(query, limit) → Result<Vec<Entity>>                  │
│  list_entities(filter, limit, offset) → Result<Vec<Entity>>  │
└─────────────────────────────────────────────────────────────┘
                    ↑                    ↑
         ┌─────────┴────────┐  ┌────────┴────────┐
         │ SimStorageBackend │  │ PostgresBackend │
         │   (testing)       │  │  (production)   │
         └──────────────────┘  └─────────────────┘
                                        │
                                        ↓
                              ┌─────────────────┐
                              │ ArchivalMemory  │
                              │  (Tier 3 API)   │
                              └─────────────────┘
```

### Files to Create

1. `umi-core/src/storage/mod.rs` - Module with trait + re-exports
2. `umi-core/src/storage/backend.rs` - StorageBackend trait
3. `umi-core/src/storage/sim.rs` - SimStorageBackend (wraps SimStorage)
4. `umi-core/src/storage/postgres.rs` - PostgresBackend (sqlx)
5. `umi-core/src/memory/archival.rs` - ArchivalMemory

### Entity Type (for storage)

```rust
#[derive(Debug, Clone)]
pub struct Entity {
    pub id: String,
    pub entity_type: EntityType,
    pub name: String,
    pub content: String,
    pub metadata: HashMap<String, String>,
    pub embedding: Option<Vec<f32>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

pub enum EntityType {
    Self_,     // User's self-representation
    Person,    // Other people
    Project,   // Projects/initiatives
    Topic,     // Topics/concepts
    Note,      // General notes
    Task,      // Tasks/todos
}
```

### Key Behaviors to Test (DST)

1. **CRUD operations** - store/get/delete/list
2. **Search** - text search returns matching entities
3. **Fault injection** - operations handle storage failures gracefully
4. **Idempotency** - re-storing same entity updates it
5. **Ordering** - list operations return consistent order
6. **Property-based** - random operations maintain invariants

### Simulation-First Order

1. Write StorageBackend trait tests using SimStorageBackend
2. Write ArchivalMemory tests using SimStorageBackend
3. Implement to make tests pass
4. Add PostgresBackend (production) last

### Dependencies to Add

```toml
[dependencies]
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres", "chrono", "uuid"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1", features = ["v4", "serde"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

---

---

## PostgresBackend Implementation Notes

**Architecture:**
- sqlx with PgPool for connection pooling (10 max connections)
- Auto-schema initialization on first connect
- JSONB for metadata column (flexible key-value)
- REAL[] array for embedding vectors (pgvector-ready)

**Schema:**
```sql
CREATE TABLE IF NOT EXISTS entities (
    id TEXT PRIMARY KEY,
    entity_type TEXT NOT NULL,
    name TEXT NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB NOT NULL DEFAULT '{}',
    embedding REAL[],
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);
```

**Indexes:**
- `idx_entities_type` - btree on entity_type for type filtering
- `idx_entities_metadata` - GIN on metadata for JSONB queries
- `idx_entities_name` - btree on name for exact matches
- `idx_entities_updated` - btree DESC for ordering

**Key Features:**
- Upsert via `ON CONFLICT (id) DO UPDATE`
- ILIKE search on name and content (case-insensitive)
- Pagination via LIMIT/OFFSET
- TigerStyle assertions (2+ per function)
- Tests skip gracefully without TEST_POSTGRES_URL

**Usage:**
```rust
// Connect
let backend = PostgresBackend::new("postgres://user:pass@localhost/umi").await?;

// Or share existing pool
let backend = PostgresBackend::from_pool(pool).await?;

// Use with ArchivalMemory
let memory = ArchivalMemory::new(Arc::new(backend));
let entity = memory.remember("Important note", EntityType::Note, None).await?;
```

---

---

## PyO3 Bindings (Phase 4)

**Exposed Types:**
- `CoreMemory` - 32KB always-in-context memory
- `WorkingMemory` - 1MB TTL-based KV store
- `Entity` - Archival memory entity

**String-Based Type Selection:**
Block types: `"system"`, `"persona"`, `"human"`, `"facts"`, `"goals"`, `"scratch"`
Entity types: `"self"`, `"person"`, `"project"`, `"topic"`, `"note"`, `"task"`

**Usage:**
```python
import umi

# Core Memory
core = umi.CoreMemory()
core.set_block("system", "You are a helpful assistant.")
core.set_block("human", "User prefers concise responses.")
context = core.render()

# Working Memory
working = umi.WorkingMemory()
working.set("session_id", b"abc123", ttl_secs=3600)
value = working.get("session_id")

# Entity
entity = umi.Entity("person", "Alice", "My friend Alice")
entity.set_meta("company", "Acme Corp")
```

**Build with Maturin:**
```bash
cd umi/umi-py
maturin develop  # For development
maturin build    # For release wheel
```

---

*Plan created: 2026-01-10*
*Phase 3 completed: 2026-01-11*
*Phase 4 completed: 2026-01-11*
