# Rust Umi Library Implementation

**Status**: IN PROGRESS
**Created**: 2026-01-10
**Type**: Implementation
**Decision**: Option B (Rust library with PyO3 bindings)

---

## Decision Summary

After analyzing options A-D:
- **Option B selected**: Rust library with PyO3 bindings
- Kelpie: native Rust dependency (`cargo add umi`)
- RikaiOS: PyO3 bindings (`pip install umi-py`)
- Each app has its own Umi instance with its own DB

See ADR-004 for full decision rationale.

---

## TigerStyle Rules (Ported from Python)

### Naming Conventions (Big-Endian)

```rust
// Category first, specifics last
const ENTITY_CONTENT_BYTES_MAX: usize = 1_000_000;      // Good
const MAX_ENTITY_CONTENT_BYTES: usize = 1_000_000;      // Bad

const STORAGE_RETRY_COUNT_MAX: u32 = 3;                 // Good
const MAX_RETRIES: u32 = 3;                             // Bad

const WORKING_MEMORY_TTL_SECS_DEFAULT: u64 = 3600;      // Good
const DEFAULT_TTL: u64 = 3600;                          // Bad
```

### Assertions (2+ per function)

```rust
pub fn store_entity(&mut self, entity: Entity) -> Result<String> {
    // Preconditions
    assert!(!entity.id.is_empty(), "entity must have id");
    assert!(
        entity.content.len() <= ENTITY_CONTENT_BYTES_MAX,
        "content exceeds {} bytes", ENTITY_CONTENT_BYTES_MAX
    );

    let result = self.storage.insert(entity)?;

    // Postconditions
    assert_eq!(result.id, entity.id, "stored id must match");
    assert!(result.created_at.is_some(), "must have timestamp");

    Ok(result.id)
}
```

### Explicit Limits

```rust
// Every limit is a named constant with units in the name
pub const CORE_MEMORY_SIZE_BYTES_MAX: usize = 32 * 1024;        // 32KB
pub const CORE_MEMORY_SIZE_BYTES_MIN: usize = 4 * 1024;         // 4KB
pub const WORKING_MEMORY_SIZE_BYTES_MAX: usize = 1024 * 1024;   // 1MB
pub const WORKING_MEMORY_ENTRY_SIZE_BYTES_MAX: usize = 64 * 1024;
pub const WORKING_MEMORY_TTL_SECS_DEFAULT: u64 = 3600;          // 1 hour
pub const SEARCH_RESULTS_COUNT_MAX: usize = 100;
pub const ENTITY_CONTENT_BYTES_MAX: usize = 1_000_000;          // 1MB
pub const EMBEDDING_DIMENSIONS_COUNT: usize = 1536;
```

---

## Simulation-First Implementation Order

```
Phase 1: DST Framework (Rust)
├── SimConfig (seed management)
├── DeterministicRng (ChaCha20)
├── SimClock (controllable time)
├── FaultInjector (probabilistic faults)
└── SimStorage (in-memory with faults)

Phase 2: Core Types (test-first)
├── MemoryBlock + MemoryBlockType
├── CoreMemory (32KB, always in context)
└── WorkingMemory (1MB KV with TTL)

Phase 3: Storage Backends (test-first)
├── StorageBackend trait
├── PostgresBackend (production)
└── Tests use SimStorage

Phase 4: PyO3 Bindings
├── umi-py crate
├── Python type conversions
└── Async runtime bridge
```

---

## Workspace Structure

```
umi/
├── Cargo.toml              # Workspace root
├── umi-core/
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── constants.rs    # All _MAX, _MIN, _DEFAULT constants
│       ├── dst/
│       │   ├── mod.rs
│       │   ├── config.rs   # SimConfig
│       │   ├── rng.rs      # DeterministicRng (ChaCha20)
│       │   ├── clock.rs    # SimClock
│       │   ├── fault.rs    # FaultInjector, FaultType
│       │   └── storage.rs  # SimStorage
│       ├── types/
│       │   ├── mod.rs
│       │   ├── memory_block.rs
│       │   └── entity.rs
│       ├── memory/
│       │   ├── mod.rs
│       │   ├── core.rs     # CoreMemory
│       │   └── working.rs  # WorkingMemory
│       └── storage/
│           ├── mod.rs
│           ├── backend.rs  # StorageBackend trait
│           └── postgres.rs # PostgresBackend
├── umi-py/
│   ├── Cargo.toml          # PyO3 bindings
│   └── src/
│       └── lib.rs
└── umi-cli/
    ├── Cargo.toml
    └── src/
        └── main.rs
```

---

## Phase 1: DST Framework

### Files to Create

1. `umi/Cargo.toml` - Workspace root
2. `umi/umi-core/Cargo.toml` - Core library
3. `umi/umi-core/src/lib.rs` - Library entry
4. `umi/umi-core/src/constants.rs` - TigerStyle constants
5. `umi/umi-core/src/dst/mod.rs` - DST module
6. `umi/umi-core/src/dst/config.rs` - SimConfig
7. `umi/umi-core/src/dst/rng.rs` - DeterministicRng
8. `umi/umi-core/src/dst/clock.rs` - SimClock
9. `umi/umi-core/src/dst/fault.rs` - FaultInjector
10. `umi/umi-core/src/dst/storage.rs` - SimStorage

### Dependencies

```toml
[dependencies]
rand = "0.8"
rand_chacha = "0.3"           # Deterministic RNG
tokio = { version = "1", features = ["full"] }
thiserror = "1"               # Error handling
async-trait = "0.1"

[dev-dependencies]
tokio-test = "0.4"
```

---

## Instance Log

| Time | Instance | Action |
|------|----------|--------|
| 2026-01-10 23:00 | Main | Started Rust Umi implementation plan |
| 2026-01-10 23:15 | Main | Created ADR-004 documenting Rust decision |
| 2026-01-10 23:20 | Main | Created workspace structure (umi-core, umi-py, umi-cli) |
| 2026-01-10 23:30 | Main | Implemented DST framework (config, rng, clock, fault, storage, simulation) |
| 2026-01-10 23:45 | Main | All 67 tests passing (59 unit + 8 doc tests) |

---

## Completed

- [x] Decision: Option B (Rust library + PyO3)
- [x] Created plan file
- [x] ADR-004: Rust Umi decision
- [x] Workspace Cargo.toml
- [x] umi-core/src/constants.rs - TigerStyle constants
- [x] umi-core/src/dst/config.rs - SimConfig
- [x] umi-core/src/dst/rng.rs - DeterministicRng (ChaCha20)
- [x] umi-core/src/dst/clock.rs - SimClock
- [x] umi-core/src/dst/fault.rs - FaultInjector (26 fault types)
- [x] umi-core/src/dst/storage.rs - SimStorage
- [x] umi-core/src/dst/simulation.rs - Simulation harness
- [x] 67 tests passing

## Next Steps

- [ ] CoreMemory implementation (test-first)
- [ ] WorkingMemory implementation (test-first)
- [ ] PyO3 bindings for RikaiOS

---

*Plan created: 2026-01-10*
